/**
 * PDF Export Module
 * Generates redacted PDFs and compliance reports
 */

import PDFDocument from 'pdfkit';

/**
 * Generate a redacted PDF document
 */
export function generateRedactedPDF(options = {}) {
  const {
    originalText,
    redactedText,
    redactions,
    flags,
    documentName = 'Redacted Document',
    includeOriginal = false,
    includeMetadata = true
  } = options;

  return new Promise((resolve, reject) => {
    try {
      const chunks = [];
      const doc = new PDFDocument({
        size: 'A4',
        margins: { top: 50, bottom: 50, left: 50, right: 50 },
        bufferPages: true,
        info: {
          Title: documentName,
          Author: 'Zero-Error Contract Review',
          Subject: 'Redacted Document',
          Keywords: 'redacted, confidential, PII removed',
          CreationDate: new Date()
        }
      });

      doc.on('data', chunk => chunks.push(chunk));
      doc.on('end', () => resolve(Buffer.concat(chunks)));
      doc.on('error', reject);

      // Header
      doc
        .fontSize(20)
        .font('Helvetica-Bold')
        .text('REDACTED DOCUMENT', { align: 'center' });

      doc
        .fontSize(10)
        .font('Helvetica')
        .fillColor('#666666')
        .text(`Generated: ${new Date().toLocaleString()}`, { align: 'center' });

      doc.moveDown(2);

      // Metadata section
      if (includeMetadata) {
        doc
          .fontSize(12)
          .font('Helvetica-Bold')
          .fillColor('#000000')
          .text('Document Information');

        doc
          .fontSize(10)
          .font('Helvetica')
          .text(`Document Name: ${documentName}`)
          .text(`Total Redactions: ${redactions.length}`)
          .text(`Flagged Sections: ${flags.length}`);

        // Redaction summary
        const redactionSummary = {};
        redactions.forEach(r => {
          redactionSummary[r.type] = (redactionSummary[r.type] || 0) + 1;
        });

        doc.moveDown();
        doc.font('Helvetica-Bold').text('Redaction Summary:');
        doc.font('Helvetica');

        for (const [type, count] of Object.entries(redactionSummary)) {
          doc.text(`  • ${type}: ${count} instance(s)`);
        }

        doc.moveDown(2);

        // Divider
        doc
          .strokeColor('#cccccc')
          .lineWidth(1)
          .moveTo(50, doc.y)
          .lineTo(545, doc.y)
          .stroke();

        doc.moveDown(2);
      }

      // Redacted Content Section
      doc
        .fontSize(14)
        .font('Helvetica-Bold')
        .fillColor('#000000')
        .text('Redacted Content');

      doc.moveDown();

      // Process redacted text - simpler approach without inline boxes
      doc.fontSize(10).font('Helvetica').fillColor('#000000');

      // Clean text and render with proper line breaks
      const cleanedText = redactedText
        .replace(/\r\n/g, '\n')
        .replace(/\r/g, '\n');

      // Render the text with redaction markers styled inline
      doc.text(cleanedText, {
        width: 495,
        align: 'left',
        lineGap: 4
      });

      doc.moveDown(2);

      // Flags section
      if (flags.length > 0) {
        doc.addPage();

        doc
          .fontSize(14)
          .font('Helvetica-Bold')
          .text('Flagged Sections');

        doc.moveDown();

        for (const flag of flags) {
          doc
            .fontSize(10)
            .font('Helvetica-Bold')
            .fillColor(flag.severity === 'HIGH' ? '#cc0000' : '#ff9900')
            .text(`[${flag.severity}] ${flag.type}`);

          doc
            .font('Helvetica')
            .fillColor('#000000')
            .text(`Reason: ${flag.reason}`)
            .text(`Excerpt: "${flag.excerpt}"`, { indent: 20 });

          doc.moveDown();
        }
      }

      // Include original text if requested (for comparison)
      if (includeOriginal) {
        doc.addPage();

        doc
          .fontSize(14)
          .font('Helvetica-Bold')
          .fillColor('#cc0000')
          .text('⚠ ORIGINAL TEXT (CONTAINS SENSITIVE DATA)', { align: 'center' });

        doc.moveDown();

        doc
          .fontSize(8)
          .font('Helvetica')
          .fillColor('#666666')
          .text('Warning: This section contains unredacted sensitive information and should be handled with care.');

        doc.moveDown();

        doc
          .strokeColor('#cc0000')
          .lineWidth(2)
          .rect(45, doc.y, 505, 20)
          .stroke();

        doc.moveDown(2);

        doc
          .fontSize(10)
          .font('Helvetica')
          .fillColor('#000000')
          .text(originalText);
      }

      // Footer on each page
      const pages = doc.bufferedPageRange();
      for (let i = 0; i < pages.count; i++) {
        doc.switchToPage(i);

        doc
          .fontSize(8)
          .fillColor('#999999')
          .text(
            `Page ${i + 1} of ${pages.count} | Generated by Zero-Error Contract Review | CONFIDENTIAL`,
            50,
            doc.page.height - 30,
            { align: 'center' }
          );
      }

      doc.end();
    } catch (error) {
      reject(error);
    }
  });
}

/**
 * Parse redacted text into segments
 */
function parseRedactedText(text) {
  const segments = [];
  const redactionPattern = /\[REDACTED:[^\]]+\]/g;
  let lastIndex = 0;
  let match;

  while ((match = redactionPattern.exec(text)) !== null) {
    // Add text before redaction
    if (match.index > lastIndex) {
      segments.push({
        text: text.slice(lastIndex, match.index),
        isRedaction: false
      });
    }

    // Add redaction
    segments.push({
      text: match[0],
      isRedaction: true
    });

    lastIndex = match.index + match[0].length;
  }

  // Add remaining text
  if (lastIndex < text.length) {
    segments.push({
      text: text.slice(lastIndex),
      isRedaction: false
    });
  }

  return segments;
}

/**
 * Generate HIPAA Compliance Report PDF
 */
export function generateHIPAAReportPDF(report) {
  return new Promise((resolve, reject) => {
    try {
      const chunks = [];
      const doc = new PDFDocument({
        size: 'A4',
        margins: { top: 50, bottom: 50, left: 50, right: 50 },
        bufferPages: true,
        info: {
          Title: 'HIPAA Compliance Report',
          Author: 'Zero-Error Contract Review',
          Subject: 'HIPAA Compliance Assessment',
          Keywords: 'HIPAA, compliance, PHI, healthcare',
          CreationDate: new Date()
        }
      });

      doc.on('data', chunk => chunks.push(chunk));
      doc.on('end', () => resolve(Buffer.concat(chunks)));
      doc.on('error', reject);

      // Title Page
      doc.moveDown(5);

      doc
        .fontSize(28)
        .font('Helvetica-Bold')
        .fillColor('#003366')
        .text('HIPAA COMPLIANCE', { align: 'center' });

      doc
        .fontSize(28)
        .text('REPORT', { align: 'center' });

      doc.moveDown(2);

      // Compliance Score Circle
      const scoreColor = report.complianceScore.score >= 90 ? '#00aa00'
        : report.complianceScore.score >= 70 ? '#ffaa00' : '#cc0000';

      doc
        .fontSize(48)
        .font('Helvetica-Bold')
        .fillColor(scoreColor)
        .text(`${report.complianceScore.score}`, { align: 'center' });

      doc
        .fontSize(16)
        .fillColor('#666666')
        .text(`Grade: ${report.complianceScore.grade}`, { align: 'center' });

      doc.moveDown(3);

      doc
        .fontSize(12)
        .font('Helvetica')
        .fillColor('#000000')
        .text(`Report ID: ${report.reportId}`, { align: 'center' })
        .text(`Generated: ${new Date(report.generatedAt).toLocaleString()}`, { align: 'center' })
        .text(`Document: ${report.documentInfo.name}`, { align: 'center' });

      // Summary Page
      doc.addPage();

      doc
        .fontSize(18)
        .font('Helvetica-Bold')
        .fillColor('#003366')
        .text('Executive Summary');

      doc.moveDown();

      doc
        .fontSize(11)
        .font('Helvetica')
        .fillColor('#000000')
        .text(report.complianceScore.interpretation);

      doc.moveDown(2);

      // Summary Table
      const summaryData = [
        ['Metric', 'Value'],
        ['Total PHI Identifiers', report.summary.totalPHIIdentifiersFound.toString()],
        ['Categories Affected', report.summary.categoriesAffected.toString()],
        ['Critical Findings', report.summary.criticalFindings.toString()],
        ['High Severity', report.summary.highFindings.toString()],
        ['Flagged Sections', report.summary.flaggedSections.toString()]
      ];

      drawTable(doc, summaryData, 50, doc.y, 250);

      doc.moveDown(3);

      // PHI Findings
      if (Object.keys(report.phiFindings).length > 0) {
        doc
          .fontSize(18)
          .font('Helvetica-Bold')
          .fillColor('#003366')
          .text('PHI Findings by Category');

        doc.moveDown();

        for (const [category, finding] of Object.entries(report.phiFindings)) {
          const severityColor = finding.severity === 'CRITICAL' ? '#cc0000'
            : finding.severity === 'HIGH' ? '#ff6600' : '#ffaa00';

          doc
            .fontSize(12)
            .font('Helvetica-Bold')
            .fillColor(severityColor)
            .text(`[${finding.severity}] ${finding.label}`);

          doc
            .fontSize(10)
            .font('Helvetica')
            .fillColor('#000000')
            .text(`${finding.description}`)
            .text(`Instances Found: ${finding.count}`);

          doc.moveDown();
        }
      }

      // Recommendations Page
      doc.addPage();

      doc
        .fontSize(18)
        .font('Helvetica-Bold')
        .fillColor('#003366')
        .text('Recommendations');

      doc.moveDown();

      for (const rec of report.recommendations) {
        const priorityColor = rec.priority === 'CRITICAL' ? '#cc0000'
          : rec.priority === 'HIGH' ? '#ff6600' : '#0066cc';

        doc
          .fontSize(12)
          .font('Helvetica-Bold')
          .fillColor(priorityColor)
          .text(`[${rec.priority}] ${rec.category}`);

        doc
          .fontSize(10)
          .font('Helvetica')
          .fillColor('#000000')
          .text(`Action: ${rec.action}`)
          .text(`Regulation: ${rec.regulation}`)
          .text(`Details: ${rec.details}`, { indent: 0 });

        doc.moveDown();
      }

      // Certification Page
      doc.addPage();

      doc
        .fontSize(18)
        .font('Helvetica-Bold')
        .fillColor('#003366')
        .text('Certification & Disclaimer');

      doc.moveDown(2);

      doc
        .fontSize(11)
        .font('Helvetica')
        .fillColor('#000000')
        .text(report.certification.statement);

      doc.moveDown(2);

      doc
        .fontSize(10)
        .font('Helvetica-Oblique')
        .fillColor('#666666')
        .text(`DISCLAIMER: ${report.certification.disclaimer}`);

      doc.moveDown(3);

      doc
        .fontSize(10)
        .font('Helvetica')
        .fillColor('#000000')
        .text(`Report Version: ${report.certification.version}`);

      // Footer on each page
      const pages = doc.bufferedPageRange();
      for (let i = 0; i < pages.count; i++) {
        doc.switchToPage(i);

        doc
          .fontSize(8)
          .fillColor('#999999')
          .text(
            `HIPAA Compliance Report | Page ${i + 1} of ${pages.count} | ${report.reportId}`,
            50,
            doc.page.height - 30,
            { align: 'center' }
          );
      }

      doc.end();
    } catch (error) {
      reject(error);
    }
  });
}

/**
 * Helper function to draw a simple table
 */
function drawTable(doc, data, x, y, width) {
  const rowHeight = 20;
  const colWidth = width / data[0].length;

  data.forEach((row, rowIndex) => {
    row.forEach((cell, colIndex) => {
      const cellX = x + colIndex * colWidth;
      const cellY = y + rowIndex * rowHeight;

      // Header row styling
      if (rowIndex === 0) {
        doc
          .rect(cellX, cellY, colWidth, rowHeight)
          .fillAndStroke('#003366', '#003366');

        doc
          .fontSize(10)
          .font('Helvetica-Bold')
          .fillColor('#ffffff')
          .text(cell, cellX + 5, cellY + 5, { width: colWidth - 10 });
      } else {
        doc
          .rect(cellX, cellY, colWidth, rowHeight)
          .stroke('#cccccc');

        doc
          .fontSize(10)
          .font('Helvetica')
          .fillColor('#000000')
          .text(cell, cellX + 5, cellY + 5, { width: colWidth - 10 });
      }
    });
  });

  return y + data.length * rowHeight;
}

/**
 * Generate combined export (redacted doc + compliance report)
 */
export async function generateFullExport(options) {
  const { text, redactedText, redactions, flags, hipaaReport, documentName } = options;

  const redactedPDF = await generateRedactedPDF({
    originalText: text,
    redactedText,
    redactions,
    flags,
    documentName,
    includeOriginal: false,
    includeMetadata: true
  });

  const complianceReportPDF = hipaaReport
    ? await generateHIPAAReportPDF(hipaaReport)
    : null;

  return {
    redactedDocument: redactedPDF,
    complianceReport: complianceReportPDF
  };
}
